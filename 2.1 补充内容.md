**证明的形式框架**：

**Voraussetzungen(前提条件): ...**
**Behauptung(主张): ...**
**Beweis(证明):** ... 

**一些符号**：

- $x ∨ y := max(x,y) (x,y \in \mathbb{R})$
- $x ∧ y := min(x,y) (x,y \in \mathbb{R})$
- $(x)_k := x(x - 1)...(x - k + 1), x \in \mathbb{R}, k \in \mathbb{N}$
- $A + B := A \bigcup B, \quad \Sigma_{j = 1}^nA_j := \bigcup_{j = 1}^nA_j$
- ↦ 代表**映射到**

为了**对随机过程进行建模**，必须首先**对其可能的结果进行精确的数学描述**。这种描述采用集合Ω的形式，称为基本空间或结果空间，Ω的元素ω称为结果。

**投掷筛子结果空间**：

- **投掷一次**：Ω = {1,2,3,4,5,6}
- **投掷n次**：$\Omega = \{1,2,3,4,5,6\}^n = \{\{a_1,...,a_n\}|a_j \in \{1,...,6\} \quad \forall j = 1,...,n\}\}$

	1. 当骰子被连续投掷n次时，我们 **需要记录每次投掷的结果，并且投掷的顺序很重要**
	2. 因此，基本空间需要能够表示所有可能的n次投掷序列
	3. 每一轮（投掷n次筛子）的结果是一个n元组：(a₁,...,aₙ)，其中 a₁ 表示第1次投掷结果，...
	4. 例如投掷6次筛子，总共有6ⁿ个不同的可能性，如果筛子是3中可能，那么总共就是6³=216个不同的可能结果。

- **同时投掷两个无法区分的骰子的基本空间**：
	Ω := {(1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (2,2),  
		(2,3), (2,4), (2,5), (2,6), (3,3), (3,4), (3,5),  
		(3,6), (4,4), (4,5), (4,6), (5,5), (5,6), (6,6)}

同理，一枚硬币被投掷无限多次，并记录正面为1、反面为0的出现情况，则这个随机过程的自然基本空间是集合：

$\Omega = \{0,1\}^{\mathbb{N}} = \{(a_j)_{j >= 1} | a_j \in \{0,1\}\}$

上述例子特别表明，当**需要描述一个随机过程在离散时间点发生并按时间顺序排列时**，**元组和序列是合适的表示工具**。

**通常我们只关心随机过程的结果是否属于某个特定的结果集。例如，在投掷两次骰子时，可能只关心所投点数之和是否等于7或者更大，这种考虑引导我们研究基本空间Ω的子集。**

空集∅被称为**不可能事件**，基本空间Ω本身被称为**必然事件**。每个单元素集{ω}⊂Ω被称为**基本事件**。

许多随机过程由按顺序进行的部分实验（阶段）组成。如果整个实验共有n个阶段，我们可以将其结果表示为n元组ω=(a₁,...,aₙ)，其中aⱼ表示第j个部分实验的结果。如果第j个部分实验通过基本空间Ωⱼ建模，那么笛卡尔积：

Ω := Ω₁ × Ω₂ × ... × Ωₙ  = {ω := (a₁,...,aₙ) | aⱼ ∈ Ωⱼ 对所有 j = 1,...,n}

如果A*ⱼ ⊆ Ωⱼ，则 Aⱼ := Ω₁ × ... × Ωⱼ₋₁ × A_ⱼ × Ωⱼ₊₁ × ... × Ωₙ  = { ω = (a₁,...,aₙ) ∈ Ω | aⱼ ∈ Aⱼ }
**描述了在第 j 个部分实验中事件A*ⱼ发生的事件**

**作为将直观事件识别为Ω的子集的逻辑结果，可以通过集合论运算从事件创建新事件**

如果A, B, A₁, A₂, ..., Aₙ, ... ⊆ Ω是事件，那么：

- ==A ∩ B是事件"**A和B都发生**"==
- ==A ∪ B是事件"**至少A或B中的一个发生**"==
- ==∩ⱼ₌₁ⁿ Aⱼ是事件"**每个事件A₁, A₂, ...都发生**"==
- ==∪ⱼ₌₁ⁿ Aⱼ是事件"**至少A₁, A₂, ...中的一个发生**"==
- ==A^c := Ω \ A 表示**事件"A不发生"**==
- ==A ∩ B = ∅ 表示**AB事件是互斥的**==
- ==A ⊆ B意味着**事件A的发生会导致事件B的发生**==

==为简洁起见，我们经常**省略集合之间的交集符号**：==

- ==ABC(C ∪ D)  == A ∩ B ∩ C ∩ (C ∪ D)==
- ==用求和符号表示（成对）**互斥事件的并集**，A + B := A ∪ B==

**练习**：针对事件ABC

- **只有A发生** ： $AB^cC^c$    
- **恰好三个事件中的两个发生**：$ABC^c + AB^cC + A^cBC$

"σ-"这个前缀在σ-代数一词中表示允许在集合运算（如并集和交集形成）中使用**可数无限多**个集合。

**σ-代数的另外一种表达：**

- 设 $\Omega = \Sigma_{n = 1}^{\infty}A_i$ 是基础空间$\Omega$的一个划分，其中 A1,A2,... 是**两两不相交的集合**
- $\mathcal{A} = \{B \subseteq \Omega|\exists T \subseteq \mathbb{N} \quad B = \sum_{n \in T}{A_i}\}$

**σ-代数的生成元**：我们称 **σ(M)为由M生成的σ-代数**。根据构造，σ(M)是包含M的最小σ-代数，即M包含于其中的生成系统或简称为σ(M)的生成元

$\sigma(M) := \bigcap\{\mathcal{A} | \mathcal{A} \subseteq P(\Omega), M \subseteq \mathcal{A}\}$

**一个σ-代数可以有不同的生成元**：

例如：

- A1 和 A2 是 $\Omega$ 的一个分解，即她们并集是 $\Omega$ ，她们的交集为空集。
- 定义两个集合族：M = { A1 } N = { A2 }
- 此时A2 是 A1 的补集
- 在这种情况下，$\sigma(M)$ 和 $\sigma(N)$ 是相同的

对于任意两个集合族M和N，她们是 $\Omega$ 的幂集的子集，她们生成相同σ-代数的**充分条件**是：

- $M \subseteq \sigma(N)$
- $N \subseteq \sigma(M)$
 
### 指示函数

指示函数显示事件A是否发生：$\mathcal{1}_A(\omega) := \{1, \omega \in A\}$

运算规则：

- $\mathcal{1}_{A \bigcap B} = \mathcal{1}_A \cdot \mathcal{1}_B$
### 柯尔莫哥洛夫公理系统

==相对频率：$r_n(A) := \frac{h_n(A)}{n}$，$h_n(A)$ 为事件 A 发生的试验次数==

==相对频率的性质：对于 $r_n : \mathcal{A} \to \mathbb{R}$==

- ==$r_n(A) >= 0, A \in \mathcal{A}$==
- ==$r_n(\Omega) = 1$==
- ==如果 A1,A2,... 两两不相交，则：$r_n(\sum_{j = 1}^{\infty}A_j) = \sum_{j = 1}^{\infty}r_n(A_j)$==

从一个钉钉实验中可以看出，n 在【1，200】变化的相对频率累积图，人们可能会尝试通过定义事件A的概率为"**极限值**"，即相对频率r_n(A)在试验次数n增加时**似乎经验上会稳定的值**

==**柯尔莫哥洛夫概率公理化之前，概率理论的频率学派理解概率的方式**==

```r
set.seed(123)

# 模拟200次图钉投掷实验
n_trials <- 2000
# `rbinom` 是 R 语言中的一个重要随机数生成函数，专门用于生成服从伯努利分布二项分布的随机数
# 二项分布简单，每次投掷只有两个结果，每次投掷结果不受之前投掷结果的影响，在相同条件下，每次投掷尖端朝上的概率保持不变
results <- rbinom(n_trials, 1, prob = 0.5)
# 累积求和函数
cumulative_freq <- cumsum(results) / 1:n_trials

# 创建数据框用于绘图
results_df <- data.frame(
    trial = 1:n_trials,
    rel_freq = cumulative_freq
)

# 绘制相对频率随试验次数的变化图
library(ggplot2)
ggplot(results_df, aes(x = trial, y = rel_freq)) +
    geom_line(color = "blue") +
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "red") +
    labs(
        title = "图钉实验中'1'的相对频率稳定性",
        x = "试验次数 n",
        y = "相对频率 r_n({1})"
    ) +
    theme_minimal() +
    # 用于设置图形 Y 轴（纵轴）的显示范围（limits）
    ylim(0, 1)
```

==**公理系统定义（1933）**==

- ==一个概率空间是一个三元组 $(\Omega, \mathcal{A}, \mathbb{P})$==
- ==$\Omega$ 是任意的非空集合==
- ==$\mathcal{A}$ 是 $\Omega$ 上的 $\sigma$-代数==
- ==$\mathbb{P}:\mathcal{A} \to \mathbb{R}$ 是一个具有以下三个特性的函数：==
	1. ==**非负性**：$\mathbb{P} >= 0, \forall A \in \mathcal{A}$==
	2. ==**归一化**：$\mathbb{P} = 1$==
	3. ==**可加性**：若$A_1,A_2,...$是$\mathcal{A}$中的两两不相交的集合，则有== 
				==$\mathbb{P}(\sum_{j = 1}^{\infty}A_j) = \sum_{j = 1}^{\infty}\mathbb{P}(A_j)$==
- ==$\mathbb{P}$ 称为**概率测度或者概率分布**==

#### Vatali不可能性定理

- **不能太贪心**: 我们不能期望在所有可能的结果集合上定义概率(必须限制在某个σ-代数上)
    
- **数学的悖论**: 这表明了集合论和测度论中的深层次问题 - 有些看似合理的要求会导致数学上的不可能结果
    
- **实际建模启示**: 在实际应用中，我们需要仔细选择合适的概率空间和可测事件集合，而不是试图囊括一切

"你不可能创建一个完美的天气预报系统，既能预测任何可能的天气现象组合，又能确保改变单个地点的温度不会影响整体预测准确性。"

==设 $\Omega := \{0,1\}^{\mathbb{N}}$，则不存在概率测度 $\mathbb{P} : \mathcal{P} \to [0,1]$ 具有以下**不变性的特性**：==

- ==$D_n$ 是通过 $\omega(a_1,a_2,...)$ 定义的映射== 
		==$D_n(\omega) := (a_1,...,a_{n-1}, 1 - a_n, a_{n + 1},...)$==
- ==$D_n(A) := \{D_n(\omega)|\omega \in A\}$==
- ==对于每个$A \subseteq \Omega$ 和 每个 n >= 1，有 $\mathbb{P}(Dn(A)) = \mathbb{P}(A)$==

原像$X^{-1}(A') = {X \in A'}$表示事件$A' \in \mathcal{A}'$对应的事件$A$，即属于$\Omega$中的事件。这个性质确保$\mathbb{P}({X \in A'})$是一个定义良好的概率，其中$\mathbb{P}$是定义在$\mathcal{A}$上的概率测度。我们因此获得了以下两个核心概念的形成。

设 $(\Omega, \mathcal{A}, \mathbb{P})$ 是一个概率空间，$(\Omega', \mathcal{A}')$ 是一个可测空间，且 $X : \Omega \to \Omega'$ 是一个随机变量。那么通过设定：

### 离散概率空间和概率质量

一个概率空间(Ω, A, P)被称为**离散的**，如果A包含Ω的所有可数子集，且存在一个可数集Ω₀ ⊆ Ω满足P(Ω₀) = 1。如果(Ω, A, P)是一个离散概率空间，且Ω₀ ⊆ Ω是一个满足P(Ω₀) = 1的可数子集，那么对于任何A ∈ A，有 ：

P(A)  = P(A ∩ Ω₀)

在离散概率空间中，我们可以通过简单地累加各点的概率质量来计算任何事件的概率。这比处理复杂的积分要简单得多。

许多更复杂的概率模型和统计方法是基于离散概率空间构建的：

- 马尔可夫链
- 泊松过程
- 贝叶斯统计中的离散先验分布
- 多项分布模型

对于离散概率空间 (Ω, A, P) 和可数集 Ω₀ ⊆ Ω 满足 P(Ω₀) = 1：

**概率质量**是指分配给每个单点事件的概率值：

- 对于每个点 ω ∈ Ω₀，其概率质量为 p(ω) = P({ω})
- 对于所有 ω ∉ Ω₀，其概率质量为 p(ω) = 0

简单来说，概率质量就是分配到离散样本空间中每个点上的概率"重量"，它完全决定了离散概率空间中各个事件的概率。

